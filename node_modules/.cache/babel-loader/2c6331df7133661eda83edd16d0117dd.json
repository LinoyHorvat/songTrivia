{"ast":null,"code":"/*\n * Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n'use strict';\n\nexports.Iconv = Iconv;\n\nconst stream = require('stream');\n\nconst util = require('util');\n\nlet bindings;\n\ntry {\n  bindings = require('./build/Release/iconv.node');\n} catch (e) {\n  if (e.code !== 'MODULE_NOT_FOUND') throw e;\n  bindings = require('./build/Debug/iconv.node');\n}\n\nconst E2BIG = bindings.E2BIG | 0;\nconst EILSEQ = bindings.EILSEQ | 0;\nconst EINVAL = bindings.EINVAL | 0; // Marker object.\n\nconst FLUSH = Buffer.alloc(0);\n\nfunction Iconv(fromEncoding, toEncoding) {\n  if (!(this instanceof Iconv)) {\n    return new Iconv(fromEncoding, toEncoding);\n  }\n\n  stream.Stream.call(this);\n  this.writable = true;\n  const conv = bindings.make(fixEncoding(fromEncoding), fixEncoding(toEncoding));\n\n  if (conv === null) {\n    throw new Error('Conversion from ' + fromEncoding + ' to ' + toEncoding + ' is not supported.');\n  }\n\n  const context_ = {\n    trailer: null\n  };\n\n  this.convert = function (input, encoding) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, encoding || 'utf8');\n    }\n\n    return convert(conv, input, null);\n  };\n\n  this.write = function (input, encoding) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, encoding || 'utf8');\n    }\n\n    let buf;\n\n    try {\n      buf = convert(conv, input, context_);\n    } catch (e) {\n      this.emit('error', e);\n      return false;\n    }\n\n    if (buf && buf.length !== 0) {\n      this.emit('data', buf);\n    }\n\n    return true;\n  };\n\n  this.end = function (input, encoding) {\n    if (typeof input !== 'undefined') {\n      this.write(input, encoding);\n    }\n\n    this.write(FLUSH);\n    this.emit('end');\n  };\n}\n\nutil.inherits(Iconv, stream.Stream);\n\nfunction fixEncoding(encoding) {\n  if (/^windows-31j$/i.test(encoding)) return 'cp932'; // Convert \"utf8\" to \"utf-8\".\n\n  return /^utf[^-]/i.test(encoding) ? 'utf-' + encoding.substr(3) : encoding;\n}\n\nfunction convert(conv, input, context) {\n  if (!Buffer.isBuffer(input) && input !== FLUSH) {\n    throw new Error('Bad argument.'); // Not a buffer or a string.\n  }\n\n  if (context !== null && context.trailer !== null && input === FLUSH) {\n    throw errnoException('EINVAL', 'Incomplete character sequence.');\n  }\n\n  if (context !== null && context.trailer !== null) {\n    if (input.length === 0) {\n      // Use the trailer directly when the input is empty,\n      // don't allocate a new buffer.\n      input = context.trailer;\n      context.trailer = null;\n    } else {\n      // Prepend input buffer with trailer from last chunk.\n      const newbuf = Buffer.alloc(context.trailer.length + input.length);\n      context.trailer.copy(newbuf, 0, 0, context.trailer.length);\n      input.copy(newbuf, context.trailer.length, 0, input.length);\n      context.trailer = null;\n      input = newbuf;\n    }\n  }\n\n  let output = Buffer.alloc(input.length * 2); // To a first approximation.\n\n  let input_start = 0;\n  let output_start = 0;\n  let input_size = input.length;\n  let output_size = output.length;\n  const inout = [0, 0];\n\n  for (;;) {\n    inout[0] = input_size;\n    inout[1] = output_size;\n    const errno = bindings.convert(input === FLUSH, conv, input, input_start, output, output_start, inout);\n    const input_consumed = input_size - inout[0];\n    const output_consumed = output_size - inout[1];\n    input_start += input_consumed;\n    input_size -= input_consumed;\n    output_start += output_consumed;\n    output_size -= output_consumed;\n\n    if (errno) {\n      if (errno === E2BIG) {\n        output_size += output.length;\n        const newbuf = Buffer.alloc(output.length * 2);\n        output.copy(newbuf, 0, 0, output_start);\n        output = newbuf;\n        continue;\n      } else if (errno === EILSEQ) {\n        throw errnoException('EILSEQ', 'Illegal character sequence.');\n      } else if (errno === EINVAL) {\n        if (context === null || input === FLUSH) {\n          throw errnoException('EINVAL', 'Incomplete character sequence.');\n        } else {\n          context.trailer = input.slice(input_start);\n          return output.slice(0, output_start);\n        }\n      } else {\n        throw 'unexpected error';\n      }\n    }\n\n    if (input !== FLUSH) {\n      input = FLUSH;\n      continue;\n    }\n\n    if (output_start < output.length) {\n      output = output.slice(0, output_start);\n    }\n\n    return output;\n  }\n}\n\nfunction errnoException(code, errmsg) {\n  const err = new Error(errmsg);\n  err.code = code;\n  return err;\n}","map":{"version":3,"sources":["/Users/linoyhorvat/Documents/bootcamp/Git/Projects/mid-project/songTrivia/node_modules/iconv/index.js"],"names":["exports","Iconv","stream","require","util","bindings","e","code","E2BIG","EILSEQ","EINVAL","FLUSH","Buffer","alloc","fromEncoding","toEncoding","Stream","call","writable","conv","make","fixEncoding","Error","context_","trailer","convert","input","encoding","from","write","buf","emit","length","end","inherits","test","substr","context","isBuffer","errnoException","newbuf","copy","output","input_start","output_start","input_size","output_size","inout","errno","input_consumed","output_consumed","slice","errmsg","err"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n'use strict';\n\nexports.Iconv = Iconv;\n\nconst stream = require('stream');\nconst util = require('util');\n\nlet bindings;\ntry {\n  bindings = require('./build/Release/iconv.node');\n}\ncatch (e) {\n  if (e.code !== 'MODULE_NOT_FOUND') throw e;\n  bindings = require('./build/Debug/iconv.node');\n}\n\nconst E2BIG = bindings.E2BIG | 0;\nconst EILSEQ = bindings.EILSEQ | 0;\nconst EINVAL = bindings.EINVAL | 0;\n\n// Marker object.\nconst FLUSH = Buffer.alloc(0);\n\nfunction Iconv(fromEncoding, toEncoding)\n{\n  if (!(this instanceof Iconv)) {\n    return new Iconv(fromEncoding, toEncoding);\n  }\n\n  stream.Stream.call(this);\n  this.writable = true;\n\n  const conv = bindings.make(fixEncoding(fromEncoding),\n                             fixEncoding(toEncoding));\n  if (conv === null) {\n    throw new Error('Conversion from ' +\n                    fromEncoding + ' to ' +\n                    toEncoding + ' is not supported.');\n  }\n\n  const context_ = { trailer: null };\n\n  this.convert = function(input, encoding) {\n    if (typeof(input) === 'string') {\n      input = Buffer.from(input, encoding || 'utf8');\n    }\n    return convert(conv, input, null);\n  };\n\n  this.write = function(input, encoding) {\n    if (typeof(input) === 'string') {\n      input = Buffer.from(input, encoding || 'utf8');\n    }\n    let buf;\n    try {\n      buf = convert(conv, input, context_);\n    }\n    catch (e) {\n      this.emit('error', e);\n      return false;\n    }\n    if (buf && buf.length !== 0) {\n      this.emit('data', buf);\n    }\n    return true;\n  };\n\n  this.end = function(input, encoding) {\n    if (typeof(input) !== 'undefined') {\n      this.write(input, encoding);\n    }\n    this.write(FLUSH);\n    this.emit('end');\n  };\n}\nutil.inherits(Iconv, stream.Stream);\n\nfunction fixEncoding(encoding)\n{\n  if (/^windows-31j$/i.test(encoding)) return 'cp932';\n  // Convert \"utf8\" to \"utf-8\".\n  return /^utf[^-]/i.test(encoding) ? 'utf-' + encoding.substr(3) : encoding;\n}\n\nfunction convert(conv, input, context) {\n  if (!Buffer.isBuffer(input) && input !== FLUSH) {\n    throw new Error('Bad argument.');  // Not a buffer or a string.\n  }\n  if (context !== null && context.trailer !== null && input === FLUSH) {\n    throw errnoException('EINVAL', 'Incomplete character sequence.');\n  }\n  if (context !== null && context.trailer !== null) {\n    if (input.length === 0) {\n      // Use the trailer directly when the input is empty,\n      // don't allocate a new buffer.\n      input = context.trailer;\n      context.trailer = null;\n    } else {\n      // Prepend input buffer with trailer from last chunk.\n      const newbuf = Buffer.alloc(context.trailer.length + input.length);\n      context.trailer.copy(newbuf, 0, 0, context.trailer.length);\n      input.copy(newbuf, context.trailer.length, 0, input.length);\n      context.trailer = null;\n      input = newbuf;\n    }\n  }\n  let output = Buffer.alloc(input.length * 2);  // To a first approximation.\n  let input_start = 0;\n  let output_start = 0;\n  let input_size = input.length;\n  let output_size = output.length;\n  const inout = [0,0];\n  for (;;) {\n    inout[0] = input_size;\n    inout[1] = output_size;\n    const errno = bindings.convert(input === FLUSH,\n                                 conv,\n                                 input,\n                                 input_start,\n                                 output,\n                                 output_start,\n                                 inout);\n    const input_consumed = input_size - inout[0];\n    const output_consumed = output_size - inout[1];\n    input_start += input_consumed;\n    input_size -= input_consumed;\n    output_start += output_consumed;\n    output_size -= output_consumed;\n    if (errno) {\n      if (errno === E2BIG) {\n        output_size += output.length;\n        const newbuf = Buffer.alloc(output.length * 2);\n        output.copy(newbuf, 0, 0, output_start);\n        output = newbuf;\n        continue;\n      }\n      else if (errno === EILSEQ) {\n        throw errnoException('EILSEQ', 'Illegal character sequence.');\n      }\n      else if (errno === EINVAL) {\n        if (context === null || input === FLUSH) {\n          throw errnoException('EINVAL', 'Incomplete character sequence.');\n        }\n        else {\n          context.trailer = input.slice(input_start);\n          return output.slice(0, output_start);\n        }\n      }\n      else {\n        throw 'unexpected error';\n      }\n    }\n    if (input !== FLUSH) {\n      input = FLUSH;\n      continue;\n    }\n    if (output_start < output.length) {\n      output = output.slice(0, output_start);\n    }\n    return output;\n  }\n}\n\nfunction errnoException(code, errmsg)\n{\n  const err = new Error(errmsg);\n  err.code = code;\n  return err;\n}\n"]},"metadata":{},"sourceType":"script"}